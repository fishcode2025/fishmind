让我根据观察到的流式数据来分析大模型调用MCP工具的完整流程：

1. **初始阶段（大模型思考和表达）**
   - 大模型首先会输出普通文本，解释它要做什么
   - 这时会收到带有 `delta.content` 的数据流
   - 例如："要确定 `employees` 表中有多少人，我们需要执行一个查询来计数。我将为您执行这个查询。"

2. **工具调用开始**
   - 当大模型决定调用工具时，会出现一个特殊的数据块
   - 包含 `delta.role = "assistant"` 和完整的工具调用信息
   - 包含工具的 ID、类型和名称
   - 例如：
   ```json
   {
     "delta": {
       "role": "assistant",
       "tool_calls": [{
         "id": "0195973b8d7bcefb38dcdc6925b43209",
         "type": "function",
         "function": {
           "name": "0a1b7e03-b6ed-4ed2-89b3-8f44ca8503e4:read_query",
           "arguments": ""
         }
       }]
     }
   }
   ```

3. **工具参数传递**
   - 大模型会分片发送工具调用的参数
   - 每个片段都包含 `delta.tool_calls[0].function.arguments` 的一部分
   - 这些参数需要被累积起来，直到形成完整的参数对象

4. **工具调用结束**
   - 当参数传递完成时，会收到一个带有 `finish_reason: "tool_calls"` 的数据块
   - 这表示工具调用的参数已经完整，可以执行工具调用了

5. **工具执行**
   - 此时我们需要执行工具调用
   - 将累积的参数传递给对应的工具函数
   - 等待工具执行完成并获取结果

6. **继续对话**
   - 工具执行完成后，将结果返回给大模型
   - 大模型会继续生成回复，解释工具执行的结果

这个流程中的关键点是：
- 工具调用是一个完整的过程，从开始到结束都有明确的标记
- 在工具调用过程中，不应该处理为普通文本内容
- 工具调用的参数是分片传递的，需要正确累积
- 只有在收到 `finish_reason: "tool_calls"` 时才真正执行工具调用

这样看来，我们需要修改代码来更准确地反映这个流程，确保工具调用的完整性和正确性。要修改代码吗？
