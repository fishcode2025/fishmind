# 聊天历史管理功能需求文档

## 1. 功能概述

实现聊天历史的保存和恢复功能，使用户能够：
- 自动保存每次聊天内容到本地存储
- 在话题列表中查看历史聊天
- 通过点击话题重新打开历史对话
- 管理历史聊天（重命名、删除等）

## 2. 详细需求

### 2.1 自动保存聊天

- **触发条件**：
  - 用户发送第一条消息时自动创建新话题
  - 聊天过程中定期自动保存（如每收到一条新消息）
  - 用户切换模型或关闭对话时保存

- **保存内容**：
  - 完整的消息历史（用户消息和AI回复）
  - 每条AI回复使用的模型信息
  - 话题元数据（创建时间、更新时间等）

### 2.2 话题管理

- **话题命名**：
  - 自动基于内容生成初始话题名称
    - 使用首条用户消息的前20-30个字符
    - 或使用AI生成的简短摘要
    - 默认格式："与[模型名称]的对话 - [日期时间]"
  - 支持用户手动重命名话题

- **话题列表**：
  - 按最后更新时间排序（最新的在前）
  - 显示话题标题、最后更新时间、使用的模型图标
  - 支持搜索和筛选功能

- **话题操作**：
  - 重命名话题
  - 删除话题
  - 导出话题（可选功能）

### 2.3 聊天恢复

- **恢复机制**：
  - 点击话题后加载完整聊天历史
  - 自动选择最后使用的模型
  - 保持消息的原始顺序和格式

- **模型切换处理**：
  - 记录每条AI回复使用的模型信息
  - 恢复对话时选择最后使用的模型
  - 在UI中可选择性地显示每条消息的模型来源

### 2.4 安全性要求

- **数据加密**：
  - 使用强加密算法保护聊天内容
  - 支持密码保护（可选）
  - 确保敏感信息安全

## 3. 技术实现方案

### 3.1 存储方案

采用**混合存储方案**，结合SQLite和文件系统：

- **SQLite数据库**：
  - 存储话题元数据和索引
  - 包含话题ID、标题、创建/更新时间、最后使用的模型等信息
  - 支持高效查询和排序

- **文件系统**：
  - 每个话题的详细聊天内容存储为单独的加密文件
  - 使用话题ID作为文件名
  - 适合存储大量聊天数据

- **数据结构**：
  ```typescript
  // 话题元数据（存储在SQLite）
  interface ChatTopic {
    id: string;                 // 唯一标识符
    title: string;              // 话题标题
    createdAt: string;          // 创建时间
    updatedAt: string;          // 最后更新时间
    lastModelId: string;        // 最后使用的模型ID
    lastProviderId: string;     // 最后使用的提供商ID
    messageCount: number;       // 消息数量
    preview: string;            // 预览内容（首条消息的摘要）
  }

  // 聊天消息（存储在加密文件中）
  interface ChatMessage {
    id: string;                 // 消息ID
    role: 'user' | 'assistant' | 'system'; // 消息角色
    content: string;            // 消息内容
    timestamp: string;          // 时间戳
    modelId?: string;           // 使用的模型ID（对于AI回复）
    providerId?: string;        // 使用的提供商ID（对于AI回复）
  }
  ```

### 3.2 加密方案

采用**分层加密与密钥派生**方案，结合平台安全存储：

- **加密算法**：
  - 使用AES-256-GCM进行内容加密
  - 使用Argon2id进行密钥派生

- **密钥管理**：
  - 主密钥(Master Key)：从用户密码派生或随机生成
  - 数据加密密钥(DEK)：为每个话题随机生成
  - 使用主密钥加密DEK，存储加密后的DEK

- **安全存储**：
  - 利用平台安全机制存储主密钥：
    - Windows: Windows Credential Manager
    - macOS: Keychain
    - Linux: Secret Service API
    - iOS: Keychain
    - Android: Keystore
  - 加密后的DEK与聊天内容一起存储

- **加密流程**：
  1. 获取或派生主密钥
  2. 为话题生成随机DEK
  3. 使用DEK加密聊天内容
  4. 使用主密钥加密DEK
  5. 存储加密后的DEK和加密后的聊天内容

- **解密流程**：
  1. 获取主密钥
  2. 解密DEK
  3. 使用DEK解密聊天内容

### 3.3 跨平台实现

基于Tauri框架的跨平台实现策略：

- **Rust后端**：
  - 实现核心存储和加密逻辑
  - 使用Tauri命令API暴露功能给前端
  - 处理文件系统操作和数据库交互

- **前端**：
  - 实现用户界面和交互逻辑
  - 通过Tauri API调用后端功能
  - 处理数据展示和用户输入

- **平台适配**：
  - 使用Tauri的API抽象平台差异
  - 针对不同平台优化存储路径和安全机制
  - 考虑移动平台的性能和存储限制

## 4. 用户界面设计

### 4.1 话题列表面板

- **位置**：应用左侧面板，与助手列表共用标签页
- **内容**：
  - 话题标题
  - 最后更新时间
  - 使用的模型图标（可选）
  - 简短预览（可选）
- **操作**：
  - 点击加载对话
  - 右键菜单提供更多操作（重命名、删除等）

### 4.2 话题管理界面

- **重命名对话框**：
  - 输入框显示当前标题
  - 确认和取消按钮
- **删除确认对话框**：
  - 警告信息
  - 确认和取消按钮

### 4.3 聊天界面集成

- **话题指示器**：
  - 显示当前话题名称
  - 提供编辑按钮
- **模型信息**：
  - 可选择性地显示每条消息使用的模型
  - 在切换模型时显示提示

## 5. 性能与安全考虑

### 5.1 性能优化

- **懒加载**：
  - 话题列表分页加载
  - 长对话历史分段加载
- **缓存策略**：
  - 缓存当前活跃话题
  - 预加载可能需要的数据
- **压缩**：
  - 考虑对长期存储的聊天内容进行压缩

### 5.2 安全措施

- **数据隔离**：
  - 不同话题使用不同的加密密钥
  - 确保即使一个话题被破解，其他话题仍然安全
- **安全擦除**：
  - 提供安全删除功能
  - 内存中敏感数据使用后立即清除
- **访问控制**：
  - 可选的应用锁定功能
  - 支持生物识别解锁（在支持的设备上）

## 6. 实现路线图

### 阶段一：基础功能

1. 设计并实现数据模型和存储服务
2. 实现基本的话题保存和加载功能
3. 更新UI组件显示话题列表
4. 实现话题点击和恢复功能

### 阶段二：增强功能

1. 实现话题管理功能（重命名、删除）
2. 添加自动命名和预览生成
3. 实现模型切换记录和恢复
4. 优化UI交互和用户体验

### 阶段三：安全与优化

1. 实现加密层和密钥管理
2. 添加性能优化（分页、缓存等）
3. 实现可选的安全功能（密码保护等）
4. 添加导出/导入功能

## 7. 测试计划

- **单元测试**：
  - 存储服务API
  - 加密/解密功能
  - 数据转换逻辑

- **集成测试**：
  - 完整的保存/恢复流程
  - 模型切换处理
  - 错误处理和恢复

- **性能测试**：
  - 大量话题的加载性能
  - 长对话的处理性能
  - 加密/解密性能

- **用户测试**：
  - 界面易用性
  - 功能完整性
  - 跨平台兼容性

## 8. 注意事项与限制

- **存储限制**：
  - 考虑设备存储容量限制
  - 提供存储使用情况指示
  - 考虑添加自动清理或归档功能

- **加密限制**：
  - 密码丢失将导致数据无法恢复
  - 加密可能影响性能，需要平衡安全性和用户体验

- **跨平台考虑**：
  - 移动平台存储空间更受限
  - 不同平台的安全机制有差异
  - UI需要适应不同屏幕尺寸

## 9. 未来扩展

- **云同步**：为不同设备间提供安全的数据同步
- **协作功能**：允许多用户共享和协作聊天
- **高级分析**：提供聊天内容的分析和洞察
- **自动标签**：基于内容自动分类和标记话题 